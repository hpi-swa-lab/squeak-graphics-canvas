/* Automatically generated by
	VMPluginCodeGenerator * VMMaker.oscog-eem.2779 uuid: 69eafb1b-0a60-46f9-ad35-00f4a863fe8a
   from
	Float32ArrayBulkPlugin * RawBitsBulkPlugins-stlu.1 uuid: 0b61b27e-d7c3-49ec-ac01-307a6db44f5e
 */
static char __buildInfo[] = "Float32ArrayBulkPlugin * RawBitsBulkPlugins-stlu.1 uuid: 0b61b27e-d7c3-49ec-ac01-307a6db44f5e " __DATE__ ;



#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadReceiver 2


/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) primitiveAtPutNew(void);
EXPORT(sqInt) primitiveAtPutNone(void);
EXPORT(sqInt) primitiveAtPutOld(void);
EXPORT(sqInt) primitiveStartingAtPut14(void);
EXPORT(sqInt) primitiveStartingAtPut2(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*failed)(void);
static void * (*firstIndexableField)(sqInt oop);
static double (*floatValueOf)(sqInt oop);
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*isWords)(sqInt oop);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*slotSizeOf)(sqInt oop);
static double (*stackFloatValue)(sqInt offset);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt failed(void);
extern void * firstIndexableField(sqInt oop);
extern double floatValueOf(sqInt oop);
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
extern sqInt isWords(sqInt oop);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt slotSizeOf(sqInt oop);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "Float32ArrayBulkPlugin * RawBitsBulkPlugins-stlu.1 " INT_EXT;



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* Float32ArrayBulkPlugin>>#primitiveAtPutNew */
EXPORT(sqInt)
primitiveAtPutNew(void)
{
    float *floatPtr;
    usqInt index;
    sqInt numSlots;
    sqInt rcvr;
    sqInt valueOop;

	valueOop = stackValue(0);
	index = ((usqInt)((integerValueOf(stackValue(1))) - 1));
	rcvr = stackValue(2);
	numSlots = slotSizeOf(rcvr);
	if (index >= numSlots) {
		return primitiveFail();
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[index] = (floatValueOf(valueOop));
	popthenPush(3, valueOop);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveAtPutNone */
EXPORT(sqInt)
primitiveAtPutNone(void)
{
    usqInt index;
    sqInt numSlots;
    sqInt rcvr;
    sqInt valueOop;

	valueOop = stackValue(0);
	index = ((usqInt)((stackIntegerValue(1)) - 1));
	rcvr = stackValue(2);
	numSlots = slotSizeOf(rcvr);
	if (index >= numSlots) {
		return primitiveFail();
	}
	floatValueOf(valueOop);
	popthenPush(3, valueOop);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveAtPutOld */
EXPORT(sqInt)
primitiveAtPutOld(void)
{
    float *floatPtr;
    double floatValue;
    sqInt index;
    sqInt rcvr;
    sqInt value;

	value = stackValue(0);
	floatValue = (isIntegerObject(value)
		? ((double) (integerValueOf(value)) )
		: floatValueOf(value));
	index = stackIntegerValue(1);
	rcvr = stackValue(2);
	if (!((!(failed()))
		 && ((isWords(rcvr))
		 && ((index > 0)
		 && (index <= (slotSizeOf(rcvr))))))) {
		return primitiveFail();
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[index - 1] = (((float) floatValue));
	popthenPush(3, value);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut14 */
EXPORT(sqInt)
primitiveStartingAtPut14(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;

	rcvr = stackValue(15);
	if (!(isWords(rcvr))) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	startIndex = (integerValueOf(stackValue(14))) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 14) > numSlots)) {
		return primitiveFail();
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(13));
	floatPtr[startIndex + 1] = (stackFloatValue(12));
	floatPtr[startIndex + 2] = (stackFloatValue(11));
	floatPtr[startIndex + 3] = (stackFloatValue(10));
	floatPtr[startIndex + 4] = (stackFloatValue(9));
	floatPtr[startIndex + 5] = (stackFloatValue(8));
	floatPtr[startIndex + 6] = (stackFloatValue(7));
	floatPtr[startIndex + 7] = (stackFloatValue(6));
	floatPtr[startIndex + 8] = (stackFloatValue(5));
	floatPtr[startIndex + 9] = (stackFloatValue(4));
	floatPtr[startIndex + 10] = (stackFloatValue(3));
	floatPtr[startIndex + 11] = (stackFloatValue(2));
	floatPtr[startIndex + 12] = (stackFloatValue(1));
	floatPtr[startIndex + 13] = (stackFloatValue(0));
	popthenPush(16, rcvr);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut2 */
EXPORT(sqInt)
primitiveStartingAtPut2(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;

	rcvr = stackValue(3);
	if (!(isWords(rcvr))) {
		return primitiveFailFor(PrimErrBadReceiver);
	}
	startIndex = (integerValueOf(stackValue(2))) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 2) > numSlots)) {
		return primitiveFail();
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(1));
	floatPtr[startIndex + 1] = (stackFloatValue(0));
	popthenPush(4, rcvr);
	return 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		failed = interpreterProxy->failed;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatValueOf = interpreterProxy->floatValueOf;
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
		isWords = interpreterProxy->isWords;
		popthenPush = interpreterProxy->popthenPush;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackFloatValue = interpreterProxy->stackFloatValue;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "Float32ArrayBulkPlugin";
void* Float32ArrayBulkPlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primitiveAtPutNew\000\000", (void*)primitiveAtPutNew},
	{(void*)_m, "primitiveAtPutNone\000\000", (void*)primitiveAtPutNone},
	{(void*)_m, "primitiveAtPutOld\000\000", (void*)primitiveAtPutOld},
	{(void*)_m, "primitiveStartingAtPut14\000\000", (void*)primitiveStartingAtPut14},
	{(void*)_m, "primitiveStartingAtPut2\000\000", (void*)primitiveStartingAtPut2},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primitiveAtPutNewAccessorDepth = 0;
signed char primitiveAtPutNoneAccessorDepth = 0;
signed char primitiveAtPutOldAccessorDepth = 0;
signed char primitiveStartingAtPut14AccessorDepth = 0;
signed char primitiveStartingAtPut2AccessorDepth = 0;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
