/* Automatically generated by
	VMPluginCodeGenerator * VMMaker.oscog-eem.2779 uuid: 69eafb1b-0a60-46f9-ad35-00f4a863fe8a
   from
	Float32ArrayBulkPlugin * RawBitsBulkPlugins-Plugins-stlu.1 uuid: c0a49a25-8255-4781-b57b-aea5d0f03a54
 */
static char __buildInfo[] = "Float32ArrayBulkPlugin * RawBitsBulkPlugins-Plugins-stlu.1 uuid: c0a49a25-8255-4781-b57b-aea5d0f03a54 " __DATE__ ;



#include "config.h"
#include <math.h>
#include "sqMathShim.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
#include "sqConfig.h"			/* Configuration options */
#include "sqVirtualMachine.h"	/*  The virtual machine proxy definition */
#include "sqPlatformSpecific.h"	/* Platform specific definitions */

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
# undef EXPORT
# define EXPORT(returnType) static returnType
# define INT_EXT "(i)"
#else
# define INT_EXT "(e)"
#endif

#include "sqMemoryAccess.h"


/*** Constants ***/
#define PrimErrBadIndex 4


/*** Function Prototypes ***/
EXPORT(const char*) getModuleName(void);
EXPORT(sqInt) primitiveAtPutNew(void);
EXPORT(sqInt) primitiveAtPutNone(void);
EXPORT(sqInt) primitiveAtPutOld(void);
EXPORT(sqInt) primitiveStartingAtPut10(void);
EXPORT(sqInt) primitiveStartingAtPut11(void);
EXPORT(sqInt) primitiveStartingAtPut12(void);
EXPORT(sqInt) primitiveStartingAtPut13(void);
EXPORT(sqInt) primitiveStartingAtPut14(void);
EXPORT(sqInt) primitiveStartingAtPut2(void);
EXPORT(sqInt) primitiveStartingAtPut3(void);
EXPORT(sqInt) primitiveStartingAtPut4(void);
EXPORT(sqInt) primitiveStartingAtPut5(void);
EXPORT(sqInt) primitiveStartingAtPut6(void);
EXPORT(sqInt) primitiveStartingAtPut7(void);
EXPORT(sqInt) primitiveStartingAtPut8(void);
EXPORT(sqInt) primitiveStartingAtPut9(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine *anInterpreter);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*failed)(void);
static void * (*firstIndexableField)(sqInt oop);
static double (*floatValueOf)(sqInt oop);
#if !defined(integerValueOf)
static sqInt (*integerValueOf)(sqInt oop);
#endif
#if !defined(isIntegerObject)
static sqInt (*isIntegerObject)(sqInt objectPointer);
#endif
static sqInt (*isWords)(sqInt oop);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*slotSizeOf)(sqInt oop);
static double (*stackFloatValue)(sqInt offset);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt failed(void);
extern void * firstIndexableField(sqInt oop);
extern double floatValueOf(sqInt oop);
#if !defined(integerValueOf)
extern sqInt integerValueOf(sqInt oop);
#endif
#if !defined(isIntegerObject)
extern sqInt isIntegerObject(sqInt objectPointer);
#endif
extern sqInt isWords(sqInt oop);
extern sqInt pop(sqInt nItems);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt slotSizeOf(sqInt oop);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName = "Float32ArrayBulkPlugin * RawBitsBulkPlugins-Plugins-stlu.1 " INT_EXT;



/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

	/* InterpreterPlugin>>#getModuleName */
EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

	/* Float32ArrayBulkPlugin>>#primitiveAtPutNew */
EXPORT(sqInt)
primitiveAtPutNew(void)
{
    float *floatPtr;
    usqInt index;
    sqInt numSlots;
    sqInt rcvr;
    sqInt valueOop;

	valueOop = stackValue(0);
	index = ((usqInt)((integerValueOf(stackValue(1))) - 1));
	rcvr = stackValue(2);
	numSlots = slotSizeOf(rcvr);
	if (index >= numSlots) {
		return primitiveFail();
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[index] = (floatValueOf(valueOop));
	popthenPush(3, valueOop);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveAtPutNone */
EXPORT(sqInt)
primitiveAtPutNone(void)
{
    usqInt index;
    sqInt numSlots;
    sqInt rcvr;
    sqInt valueOop;

	valueOop = stackValue(0);
	index = ((usqInt)((stackIntegerValue(1)) - 1));
	rcvr = stackValue(2);
	numSlots = slotSizeOf(rcvr);
	if (index >= numSlots) {
		return primitiveFail();
	}
	floatValueOf(valueOop);
	popthenPush(3, valueOop);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveAtPutOld */
EXPORT(sqInt)
primitiveAtPutOld(void)
{
    float *floatPtr;
    double floatValue;
    sqInt index;
    sqInt rcvr;
    sqInt value;

	value = stackValue(0);
	floatValue = (isIntegerObject(value)
		? ((double) (integerValueOf(value)) )
		: floatValueOf(value));
	index = stackIntegerValue(1);
	rcvr = stackValue(2);
	if (!((!(failed()))
		 && ((isWords(rcvr))
		 && ((index > 0)
		 && (index <= (slotSizeOf(rcvr))))))) {
		return primitiveFail();
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[index - 1] = (((float) floatValue));
	popthenPush(3, value);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut10 */
EXPORT(sqInt)
primitiveStartingAtPut10(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(11);
	startIndex = (stackIntegerValue(10)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 10) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(9));
	floatPtr[startIndex + 1] = (stackFloatValue(8));
	floatPtr[startIndex + 2] = (stackFloatValue(7));
	floatPtr[startIndex + 3] = (stackFloatValue(6));
	floatPtr[startIndex + 4] = (stackFloatValue(5));
	floatPtr[startIndex + 5] = (stackFloatValue(4));
	floatPtr[startIndex + 6] = (stackFloatValue(3));
	floatPtr[startIndex + 7] = (stackFloatValue(2));
	floatPtr[startIndex + 8] = (stackFloatValue(1));
	floatPtr[startIndex + 9] = (stackFloatValue(0));
	pop(11);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut11 */
EXPORT(sqInt)
primitiveStartingAtPut11(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(12);
	startIndex = (stackIntegerValue(11)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 11) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(10));
	floatPtr[startIndex + 1] = (stackFloatValue(9));
	floatPtr[startIndex + 2] = (stackFloatValue(8));
	floatPtr[startIndex + 3] = (stackFloatValue(7));
	floatPtr[startIndex + 4] = (stackFloatValue(6));
	floatPtr[startIndex + 5] = (stackFloatValue(5));
	floatPtr[startIndex + 6] = (stackFloatValue(4));
	floatPtr[startIndex + 7] = (stackFloatValue(3));
	floatPtr[startIndex + 8] = (stackFloatValue(2));
	floatPtr[startIndex + 9] = (stackFloatValue(1));
	floatPtr[startIndex + 10] = (stackFloatValue(0));
	pop(12);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut12 */
EXPORT(sqInt)
primitiveStartingAtPut12(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(13);
	startIndex = (stackIntegerValue(12)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 12) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(11));
	floatPtr[startIndex + 1] = (stackFloatValue(10));
	floatPtr[startIndex + 2] = (stackFloatValue(9));
	floatPtr[startIndex + 3] = (stackFloatValue(8));
	floatPtr[startIndex + 4] = (stackFloatValue(7));
	floatPtr[startIndex + 5] = (stackFloatValue(6));
	floatPtr[startIndex + 6] = (stackFloatValue(5));
	floatPtr[startIndex + 7] = (stackFloatValue(4));
	floatPtr[startIndex + 8] = (stackFloatValue(3));
	floatPtr[startIndex + 9] = (stackFloatValue(2));
	floatPtr[startIndex + 10] = (stackFloatValue(1));
	floatPtr[startIndex + 11] = (stackFloatValue(0));
	pop(13);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut13 */
EXPORT(sqInt)
primitiveStartingAtPut13(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(14);
	startIndex = (stackIntegerValue(13)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 13) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(12));
	floatPtr[startIndex + 1] = (stackFloatValue(11));
	floatPtr[startIndex + 2] = (stackFloatValue(10));
	floatPtr[startIndex + 3] = (stackFloatValue(9));
	floatPtr[startIndex + 4] = (stackFloatValue(8));
	floatPtr[startIndex + 5] = (stackFloatValue(7));
	floatPtr[startIndex + 6] = (stackFloatValue(6));
	floatPtr[startIndex + 7] = (stackFloatValue(5));
	floatPtr[startIndex + 8] = (stackFloatValue(4));
	floatPtr[startIndex + 9] = (stackFloatValue(3));
	floatPtr[startIndex + 10] = (stackFloatValue(2));
	floatPtr[startIndex + 11] = (stackFloatValue(1));
	floatPtr[startIndex + 12] = (stackFloatValue(0));
	pop(14);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut14 */
EXPORT(sqInt)
primitiveStartingAtPut14(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(15);
	startIndex = (stackIntegerValue(14)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 14) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(13));
	floatPtr[startIndex + 1] = (stackFloatValue(12));
	floatPtr[startIndex + 2] = (stackFloatValue(11));
	floatPtr[startIndex + 3] = (stackFloatValue(10));
	floatPtr[startIndex + 4] = (stackFloatValue(9));
	floatPtr[startIndex + 5] = (stackFloatValue(8));
	floatPtr[startIndex + 6] = (stackFloatValue(7));
	floatPtr[startIndex + 7] = (stackFloatValue(6));
	floatPtr[startIndex + 8] = (stackFloatValue(5));
	floatPtr[startIndex + 9] = (stackFloatValue(4));
	floatPtr[startIndex + 10] = (stackFloatValue(3));
	floatPtr[startIndex + 11] = (stackFloatValue(2));
	floatPtr[startIndex + 12] = (stackFloatValue(1));
	floatPtr[startIndex + 13] = (stackFloatValue(0));
	pop(15);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut2 */
EXPORT(sqInt)
primitiveStartingAtPut2(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(3);
	startIndex = (stackIntegerValue(2)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 2) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(1));
	floatPtr[startIndex + 1] = (stackFloatValue(0));
	pop(3);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut3 */
EXPORT(sqInt)
primitiveStartingAtPut3(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(4);
	startIndex = (stackIntegerValue(3)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 3) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(2));
	floatPtr[startIndex + 1] = (stackFloatValue(1));
	floatPtr[startIndex + 2] = (stackFloatValue(0));
	pop(4);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut4 */
EXPORT(sqInt)
primitiveStartingAtPut4(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(5);
	startIndex = (stackIntegerValue(4)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 4) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(3));
	floatPtr[startIndex + 1] = (stackFloatValue(2));
	floatPtr[startIndex + 2] = (stackFloatValue(1));
	floatPtr[startIndex + 3] = (stackFloatValue(0));
	pop(5);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut5 */
EXPORT(sqInt)
primitiveStartingAtPut5(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(6);
	startIndex = (stackIntegerValue(5)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 5) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(4));
	floatPtr[startIndex + 1] = (stackFloatValue(3));
	floatPtr[startIndex + 2] = (stackFloatValue(2));
	floatPtr[startIndex + 3] = (stackFloatValue(1));
	floatPtr[startIndex + 4] = (stackFloatValue(0));
	pop(6);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut6 */
EXPORT(sqInt)
primitiveStartingAtPut6(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(7);
	startIndex = (stackIntegerValue(6)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 6) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(5));
	floatPtr[startIndex + 1] = (stackFloatValue(4));
	floatPtr[startIndex + 2] = (stackFloatValue(3));
	floatPtr[startIndex + 3] = (stackFloatValue(2));
	floatPtr[startIndex + 4] = (stackFloatValue(1));
	floatPtr[startIndex + 5] = (stackFloatValue(0));
	pop(7);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut7 */
EXPORT(sqInt)
primitiveStartingAtPut7(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(8);
	startIndex = (stackIntegerValue(7)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 7) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(6));
	floatPtr[startIndex + 1] = (stackFloatValue(5));
	floatPtr[startIndex + 2] = (stackFloatValue(4));
	floatPtr[startIndex + 3] = (stackFloatValue(3));
	floatPtr[startIndex + 4] = (stackFloatValue(2));
	floatPtr[startIndex + 5] = (stackFloatValue(1));
	floatPtr[startIndex + 6] = (stackFloatValue(0));
	pop(8);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut8 */
EXPORT(sqInt)
primitiveStartingAtPut8(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(9);
	startIndex = (stackIntegerValue(8)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 8) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(7));
	floatPtr[startIndex + 1] = (stackFloatValue(6));
	floatPtr[startIndex + 2] = (stackFloatValue(5));
	floatPtr[startIndex + 3] = (stackFloatValue(4));
	floatPtr[startIndex + 4] = (stackFloatValue(3));
	floatPtr[startIndex + 5] = (stackFloatValue(2));
	floatPtr[startIndex + 6] = (stackFloatValue(1));
	floatPtr[startIndex + 7] = (stackFloatValue(0));
	pop(9);
	return 0;
}

	/* Float32ArrayBulkPlugin>>#primitiveStartingAtPut9 */
EXPORT(sqInt)
primitiveStartingAtPut9(void)
{
    float *floatPtr;
    sqInt numSlots;
    sqInt rcvr;
    sqInt startIndex;


	/* (interpreterProxy isWords: rcvr) ifFalse:
	   [^interpreterProxy primitiveFailFor: PrimErrBadReceiver]. */
	rcvr = stackValue(10);
	startIndex = (stackIntegerValue(9)) - 1;
	numSlots = slotSizeOf(rcvr);
	if ((startIndex < 0)
	 || ((startIndex + 9) > numSlots)) {
		return primitiveFailFor(PrimErrBadIndex);
	}
	floatPtr = ((float *) (firstIndexableField(rcvr)));
	floatPtr[startIndex] = (stackFloatValue(8));
	floatPtr[startIndex + 1] = (stackFloatValue(7));
	floatPtr[startIndex + 2] = (stackFloatValue(6));
	floatPtr[startIndex + 3] = (stackFloatValue(5));
	floatPtr[startIndex + 4] = (stackFloatValue(4));
	floatPtr[startIndex + 5] = (stackFloatValue(3));
	floatPtr[startIndex + 6] = (stackFloatValue(2));
	floatPtr[startIndex + 7] = (stackFloatValue(1));
	floatPtr[startIndex + 8] = (stackFloatValue(0));
	pop(10);
	return 0;
}


/*	Note: This is coded so that it can be run in Squeak. */

	/* InterpreterPlugin>>#setInterpreter: */
EXPORT(sqInt)
setInterpreter(struct VirtualMachine *anInterpreter)
{
    sqInt ok;


	/* This may seem tautological, but in a real plugin it checks that the VM provides
	   the version the plugin was compiled against which is the version the plugin expects. */
	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		failed = interpreterProxy->failed;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatValueOf = interpreterProxy->floatValueOf;
#if !defined(integerValueOf)
		integerValueOf = interpreterProxy->integerValueOf;
#endif
#if !defined(isIntegerObject)
		isIntegerObject = interpreterProxy->isIntegerObject;
#endif
		isWords = interpreterProxy->isWords;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackFloatValue = interpreterProxy->stackFloatValue;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackValue = interpreterProxy->stackValue;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

static char _m[] = "Float32ArrayBulkPlugin";
void* Float32ArrayBulkPlugin_exports[][3] = {
	{(void*)_m, "getModuleName", (void*)getModuleName},
	{(void*)_m, "primitiveAtPutNew\000\000", (void*)primitiveAtPutNew},
	{(void*)_m, "primitiveAtPutNone\000\000", (void*)primitiveAtPutNone},
	{(void*)_m, "primitiveAtPutOld\000\000", (void*)primitiveAtPutOld},
	{(void*)_m, "primitiveStartingAtPut10\000\000", (void*)primitiveStartingAtPut10},
	{(void*)_m, "primitiveStartingAtPut11\000\000", (void*)primitiveStartingAtPut11},
	{(void*)_m, "primitiveStartingAtPut12\000\000", (void*)primitiveStartingAtPut12},
	{(void*)_m, "primitiveStartingAtPut13\000\000", (void*)primitiveStartingAtPut13},
	{(void*)_m, "primitiveStartingAtPut14\000\000", (void*)primitiveStartingAtPut14},
	{(void*)_m, "primitiveStartingAtPut2\000\000", (void*)primitiveStartingAtPut2},
	{(void*)_m, "primitiveStartingAtPut3\000\000", (void*)primitiveStartingAtPut3},
	{(void*)_m, "primitiveStartingAtPut4\000\000", (void*)primitiveStartingAtPut4},
	{(void*)_m, "primitiveStartingAtPut5\000\000", (void*)primitiveStartingAtPut5},
	{(void*)_m, "primitiveStartingAtPut6\000\000", (void*)primitiveStartingAtPut6},
	{(void*)_m, "primitiveStartingAtPut7\000\000", (void*)primitiveStartingAtPut7},
	{(void*)_m, "primitiveStartingAtPut8\000\000", (void*)primitiveStartingAtPut8},
	{(void*)_m, "primitiveStartingAtPut9\000\000", (void*)primitiveStartingAtPut9},
	{(void*)_m, "setInterpreter", (void*)setInterpreter},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primitiveAtPutNewAccessorDepth = 0;
signed char primitiveAtPutNoneAccessorDepth = 0;
signed char primitiveAtPutOldAccessorDepth = 0;
signed char primitiveStartingAtPut10AccessorDepth = 0;
signed char primitiveStartingAtPut11AccessorDepth = 0;
signed char primitiveStartingAtPut12AccessorDepth = 0;
signed char primitiveStartingAtPut13AccessorDepth = 0;
signed char primitiveStartingAtPut14AccessorDepth = 0;
signed char primitiveStartingAtPut2AccessorDepth = 0;
signed char primitiveStartingAtPut3AccessorDepth = 0;
signed char primitiveStartingAtPut4AccessorDepth = 0;
signed char primitiveStartingAtPut5AccessorDepth = 0;
signed char primitiveStartingAtPut6AccessorDepth = 0;
signed char primitiveStartingAtPut7AccessorDepth = 0;
signed char primitiveStartingAtPut8AccessorDepth = 0;
signed char primitiveStartingAtPut9AccessorDepth = 0;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
